"""
Production Security Features

Comprehensive security implementation including:
- Authentication and authorization
- Rate limiting and DDoS protection
- Input sanitization and validation
- PII detection and redaction
- Security monitoring and alerting
- API key management
- Content filtering
"""

import re
import time
import hashlib
import secrets
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass
import json
import redis
from fastapi import HTTPException, Request, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
from passlib.context import CryptContext

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Security patterns
PII_PATTERNS = {
    'email': re.compile(r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'),
    'phone': re.compile(r'\\b(?:\\+?1[-.]?)?\\(?([0-9]{3})\\)?[-.]?([0-9]{3})[-.]?([0-9]{4})\\b'),
    'ssn': re.compile(r'\\b(?!000|666|9\\d{2})\\d{3}-(?!00)\\d{2}-(?!0000)\\d{4}\\b'),
    'credit_card': re.compile(r'\\b(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3[0-9]{13}|6(?:011|5[0-9]{2})[0-9]{12})\\b'),
    'ip_address': re.compile(r'\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b')
}\n\nPROFANITY_WORDS = {\n    'mild': ['damn', 'hell', 'crap', 'stupid', 'idiot'],\n    'moderate': ['ass', 'bitch', 'bastard', 'shit', 'piss'],\n    'severe': ['fuck', 'motherfucker', 'cocksucker']  # Filtered for production\n}\n\nSUSPICIOUS_PATTERNS = [\n    re.compile(r'<script.*?>.*?</script>', re.IGNORECASE | re.DOTALL),\n    re.compile(r'javascript:', re.IGNORECASE),\n    re.compile(r'on\\w+\\s*=', re.IGNORECASE),\n    re.compile(r'union.*select', re.IGNORECASE),\n    re.compile(r'drop\\s+table', re.IGNORECASE),\n    re.compile(r'exec\\s*\\(', re.IGNORECASE)\n]\n\n@dataclass\nclass SecurityEvent:\n    event_type: str\n    severity: str\n    user_id: Optional[str]\n    ip_address: str\n    user_agent: str\n    details: Dict[str, Any]\n    timestamp: datetime\n\nclass RateLimiter:\n    \"\"\"Advanced rate limiting with multiple strategies\"\"\"\n    \n    def __init__(self, redis_client=None):\n        self.redis_client = redis_client or redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)\n        self.rules = {\n            'global': {'requests': 1000, 'window': 3600},  # 1000 requests per hour globally\n            'per_ip': {'requests': 100, 'window': 3600},   # 100 requests per hour per IP\n            'per_user': {'requests': 200, 'window': 3600}, # 200 requests per hour per user\n            'query': {'requests': 50, 'window': 3600},     # 50 queries per hour per user\n            'upload': {'requests': 10, 'window': 3600}     # 10 uploads per hour per user\n        }\n    \n    def check_rate_limit(self, identifier: str, rule_type: str = 'per_ip') -> Tuple[bool, Dict[str, Any]]:\n        \"\"\"Check if request is within rate limits\"\"\"\n        if rule_type not in self.rules:\n            return True, {}\n        \n        rule = self.rules[rule_type]\n        key = f\"rate_limit:{rule_type}:{identifier}\"\n        window = rule['window']\n        limit = rule['requests']\n        \n        try:\n            # Sliding window log approach\n            now = time.time()\n            pipeline = self.redis_client.pipeline()\n            \n            # Remove old entries\n            pipeline.zremrangebyscore(key, 0, now - window)\n            \n            # Count current requests\n            pipeline.zcard(key)\n            \n            # Add current request\n            pipeline.zadd(key, {str(now): now})\n            \n            # Set expiration\n            pipeline.expire(key, window)\n            \n            results = pipeline.execute()\n            current_count = results[1]\n            \n            if current_count >= limit:\n                # Get time until reset\n                oldest_request = self.redis_client.zrange(key, 0, 0, withscores=True)\n                reset_time = int(oldest_request[0][1] + window) if oldest_request else int(now + window)\n                \n                return False, {\n                    'limit': limit,\n                    'remaining': 0,\n                    'reset_time': reset_time,\n                    'current_count': current_count\n                }\n            \n            return True, {\n                'limit': limit,\n                'remaining': limit - current_count - 1,\n                'reset_time': int(now + window),\n                'current_count': current_count + 1\n            }\n            \n        except Exception as e:\n            logger.error(f\"Rate limiting error: {str(e)}\")\n            # Fail open in case of Redis issues\n            return True, {}\n    \n    def is_ip_blocked(self, ip_address: str) -> bool:\n        \"\"\"Check if IP is blocked\"\"\"\n        try:\n            block_key = f\"blocked_ip:{ip_address}\"\n            return self.redis_client.exists(block_key)\n        except:\n            return False\n    \n    def block_ip(self, ip_address: str, duration_seconds: int = 3600, reason: str = \"\"):\n        \"\"\"Block an IP address\"\"\"\n        try:\n            block_key = f\"blocked_ip:{ip_address}\"\n            block_data = {\n                'blocked_at': time.time(),\n                'duration': duration_seconds,\n                'reason': reason\n            }\n            self.redis_client.setex(block_key, duration_seconds, json.dumps(block_data))\n            logger.warning(f\"Blocked IP {ip_address} for {duration_seconds}s: {reason}\")\n        except Exception as e:\n            logger.error(f\"Error blocking IP: {str(e)}\")\n\nclass InputSanitizer:\n    \"\"\"Input sanitization and validation\"\"\"\n    \n    def __init__(self):\n        self.max_input_length = 10000\n        self.max_file_size = 10 * 1024 * 1024  # 10MB\n        \n    def sanitize_query(self, query: str) -> Tuple[str, List[str]]:\n        \"\"\"Sanitize user query and return warnings\"\"\"\n        warnings = []\n        original_query = query\n        \n        # Length check\n        if len(query) > self.max_input_length:\n            query = query[:self.max_input_length]\n            warnings.append(f\"Input truncated to {self.max_input_length} characters\")\n        \n        # Remove suspicious patterns\n        for pattern in SUSPICIOUS_PATTERNS:\n            if pattern.search(query):\n                query = pattern.sub('[REDACTED]', query)\n                warnings.append(\"Potentially malicious content removed\")\n        \n        # HTML encoding for safety\n        query = query.replace('<', '&lt;').replace('>', '&gt;')\n        \n        # Remove excessive whitespace\n        query = re.sub(r'\\s+', ' ', query).strip()\n        \n        if query != original_query:\n            logger.warning(f\"Query sanitized: {len(warnings)} issues found\")\n        \n        return query, warnings\n    \n    def detect_pii(self, text: str) -> Dict[str, List[str]]:\n        \"\"\"Detect PII in text\"\"\"\n        detected_pii = {}\n        \n        for pii_type, pattern in PII_PATTERNS.items():\n            matches = pattern.findall(text)\n            if matches:\n                detected_pii[pii_type] = matches\n        \n        return detected_pii\n    \n    def redact_pii(self, text: str, redaction_char: str = '*') -> Tuple[str, Dict[str, int]]:\n        \"\"\"Redact PII from text\"\"\"\n        redacted_text = text\n        redaction_count = {}\n        \n        for pii_type, pattern in PII_PATTERNS.items():\n            matches = pattern.findall(redacted_text)\n            if matches:\n                redaction_count[pii_type] = len(matches)\n                # Replace with asterisks of same length\n                for match in matches:\n                    if isinstance(match, tuple):  # Phone number groups\n                        original = f\"({match[0]}) {match[1]}-{match[2]}\"\n                        replacement = redaction_char * len(original)\n                    else:\n                        replacement = redaction_char * len(match)\n                    \n                    redacted_text = redacted_text.replace(match if not isinstance(match, tuple) else original, replacement, 1)\n        \n        if redaction_count:\n            logger.info(f\"PII redacted: {redaction_count}\")\n        \n        return redacted_text, redaction_count\n    \n    def check_profanity(self, text: str) -> Dict[str, Any]:\n        \"\"\"Check for profanity in text\"\"\"\n        text_lower = text.lower()\n        profanity_found = {'mild': [], 'moderate': [], 'severe': []}\n        \n        for severity, words in PROFANITY_WORDS.items():\n            for word in words:\n                if word in text_lower:\n                    profanity_found[severity].append(word)\n        \n        total_count = sum(len(words) for words in profanity_found.values())\n        \n        return {\n            'has_profanity': total_count > 0,\n            'severity_level': self._get_max_severity(profanity_found),\n            'words_found': profanity_found,\n            'total_count': total_count\n        }\n    \n    def _get_max_severity(self, profanity_found: Dict[str, List[str]]) -> str:\n        \"\"\"Get the maximum severity level found\"\"\"\n        if profanity_found['severe']:\n            return 'severe'\n        elif profanity_found['moderate']:\n            return 'moderate'\n        elif profanity_found['mild']:\n            return 'mild'\n        return 'none'\n    \n    def validate_file_upload(self, filename: str, file_size: int, file_content: bytes) -> Tuple[bool, List[str]]:\n        \"\"\"Validate uploaded file\"\"\"\n        warnings = []\n        \n        # Size check\n        if file_size > self.max_file_size:\n            return False, [f\"File size {file_size} exceeds limit {self.max_file_size}\"]\n        \n        # Extension check\n        allowed_extensions = {'.pdf', '.txt', '.md', '.doc', '.docx', '.jpg', '.png'}\n        file_ext = '.' + filename.split('.')[-1].lower() if '.' in filename else ''\n        \n        if file_ext not in allowed_extensions:\n            return False, [f\"File type {file_ext} not allowed\"]\n        \n        # Content type validation (basic)\n        if file_ext in {'.jpg', '.png'} and not file_content.startswith((b'\\xff\\xd8', b'\\x89PNG')):\n            warnings.append(\"File extension doesn't match content type\")\n        \n        # Filename sanitization\n        if re.search(r'[<>:\"/\\\\|?*]', filename):\n            warnings.append(\"Filename contains potentially unsafe characters\")\n        \n        return True, warnings\n\nclass AuthenticationManager:\n    \"\"\"JWT-based authentication system\"\"\"\n    \n    def __init__(self, secret_key: str = None):\n        self.secret_key = secret_key or secrets.token_urlsafe(32)\n        self.pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n        self.algorithm = \"HS256\"\n        self.access_token_expire = timedelta(hours=24)\n        \n        # In-memory user store (replace with database in production)\n        self.users = {}\n        self.api_keys = {}\n    \n    def create_user(self, username: str, password: str, email: str, role: str = \"user\") -> bool:\n        \"\"\"Create a new user\"\"\"\n        if username in self.users:\n            return False\n        \n        hashed_password = self.pwd_context.hash(password)\n        self.users[username] = {\n            'username': username,\n            'email': email,\n            'password_hash': hashed_password,\n            'role': role,\n            'created_at': datetime.now(),\n            'last_login': None,\n            'is_active': True\n        }\n        \n        logger.info(f\"User created: {username}\")\n        return True\n    \n    def authenticate_user(self, username: str, password: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Authenticate user with username/password\"\"\"\n        user = self.users.get(username)\n        if not user or not user['is_active']:\n            return None\n        \n        if not self.pwd_context.verify(password, user['password_hash']):\n            return None\n        \n        user['last_login'] = datetime.now()\n        return user\n    \n    def create_access_token(self, user: Dict[str, Any]) -> str:\n        \"\"\"Create JWT access token\"\"\"\n        payload = {\n            'sub': user['username'],\n            'role': user['role'],\n            'exp': datetime.utcnow() + self.access_token_expire,\n            'iat': datetime.utcnow()\n        }\n        \n        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)\n    \n    def verify_token(self, token: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Verify JWT token\"\"\"\n        try:\n            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])\n            username = payload.get('sub')\n            \n            if username is None:\n                return None\n            \n            user = self.users.get(username)\n            if not user or not user['is_active']:\n                return None\n            \n            return {\n                'username': username,\n                'role': payload.get('role', 'user'),\n                'exp': payload.get('exp')\n            }\n        \n        except jwt.PyJWTError:\n            return None\n    \n    def create_api_key(self, username: str, name: str = \"\") -> str:\n        \"\"\"Create API key for user\"\"\"\n        api_key = f\"sk-{secrets.token_urlsafe(32)}\"\n        key_hash = hashlib.sha256(api_key.encode()).hexdigest()\n        \n        self.api_keys[key_hash] = {\n            'username': username,\n            'name': name,\n            'created_at': datetime.now(),\n            'last_used': None,\n            'is_active': True\n        }\n        \n        logger.info(f\"API key created for user: {username}\")\n        return api_key\n    \n    def verify_api_key(self, api_key: str) -> Optional[str]:\n        \"\"\"Verify API key and return username\"\"\"\n        key_hash = hashlib.sha256(api_key.encode()).hexdigest()\n        key_info = self.api_keys.get(key_hash)\n        \n        if not key_info or not key_info['is_active']:\n            return None\n        \n        key_info['last_used'] = datetime.now()\n        return key_info['username']\n\nclass SecurityMonitor:\n    \"\"\"Security event monitoring and alerting\"\"\"\n    \n    def __init__(self, redis_client=None):\n        self.redis_client = redis_client or redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)\n        self.events = []\n        self.alert_thresholds = {\n            'failed_auth': 5,      # 5 failed attempts in window\n            'rate_limit_hit': 10,  # 10 rate limit hits\n            'pii_detected': 3,     # 3 PII detections\n            'suspicious_activity': 1  # 1 suspicious activity\n        }\n        self.alert_window = 300  # 5 minutes\n    \n    def log_security_event(\n        self, \n        event_type: str, \n        severity: str, \n        request: Request, \n        user_id: Optional[str] = None,\n        details: Dict[str, Any] = None\n    ):\n        \"\"\"Log a security event\"\"\"\n        event = SecurityEvent(\n            event_type=event_type,\n            severity=severity,\n            user_id=user_id,\n            ip_address=request.client.host,\n            user_agent=request.headers.get('user-agent', ''),\n            details=details or {},\n            timestamp=datetime.now()\n        )\n        \n        # Store in memory (implement persistent storage in production)\n        self.events.append(event)\n        \n        # Store in Redis for alerting\n        try:\n            event_key = f\"security_event:{event_type}:{request.client.host}\"\n            pipeline = self.redis_client.pipeline()\n            pipeline.zadd(event_key, {str(time.time()): time.time()})\n            pipeline.expire(event_key, self.alert_window)\n            pipeline.execute()\n        except Exception as e:\n            logger.error(f\"Error storing security event: {str(e)}\")\n        \n        # Check for alerts\n        self._check_alert_thresholds(event_type, request.client.host)\n        \n        logger.warning(f\"Security event: {event_type} from {request.client.host} ({severity})\")\n    \n    def _check_alert_thresholds(self, event_type: str, ip_address: str):\n        \"\"\"Check if alert thresholds are exceeded\"\"\"\n        if event_type not in self.alert_thresholds:\n            return\n        \n        try:\n            event_key = f\"security_event:{event_type}:{ip_address}\"\n            recent_events = self.redis_client.zcount(\n                event_key, \n                time.time() - self.alert_window, \n                time.time()\n            )\n            \n            threshold = self.alert_thresholds[event_type]\n            \n            if recent_events >= threshold:\n                self._trigger_alert(event_type, ip_address, recent_events, threshold)\n        \n        except Exception as e:\n            logger.error(f\"Error checking alert thresholds: {str(e)}\")\n    \n    def _trigger_alert(self, event_type: str, ip_address: str, count: int, threshold: int):\n        \"\"\"Trigger security alert\"\"\"\n        alert = {\n            'type': 'security_alert',\n            'event_type': event_type,\n            'ip_address': ip_address,\n            'count': count,\n            'threshold': threshold,\n            'timestamp': datetime.now().isoformat()\n        }\n        \n        # Log alert\n        logger.critical(f\"SECURITY ALERT: {event_type} from {ip_address} - {count} events (threshold: {threshold})\")\n        \n        # In production, send to alerting system (email, Slack, PagerDuty, etc.)\n        # self.send_alert_notification(alert)\n    \n    def get_security_summary(self, hours: int = 24) -> Dict[str, Any]:\n        \"\"\"Get security summary for specified time period\"\"\"\n        cutoff_time = datetime.now() - timedelta(hours=hours)\n        recent_events = [e for e in self.events if e.timestamp >= cutoff_time]\n        \n        # Aggregate by type\n        event_counts = {}\n        severity_counts = {'low': 0, 'medium': 0, 'high': 0, 'critical': 0}\n        ip_addresses = set()\n        \n        for event in recent_events:\n            event_counts[event.event_type] = event_counts.get(event.event_type, 0) + 1\n            severity_counts[event.severity] = severity_counts.get(event.severity, 0) + 1\n            ip_addresses.add(event.ip_address)\n        \n        return {\n            'time_period_hours': hours,\n            'total_events': len(recent_events),\n            'unique_ips': len(ip_addresses),\n            'event_types': event_counts,\n            'severity_breakdown': severity_counts,\n            'most_active_ips': self._get_most_active_ips(recent_events)\n        }\n    \n    def _get_most_active_ips(self, events: List[SecurityEvent], limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"Get most active IP addresses\"\"\"\n        ip_counts = {}\n        for event in events:\n            ip = event.ip_address\n            if ip not in ip_counts:\n                ip_counts[ip] = {'count': 0, 'event_types': set()}\n            ip_counts[ip]['count'] += 1\n            ip_counts[ip]['event_types'].add(event.event_type)\n        \n        sorted_ips = sorted(ip_counts.items(), key=lambda x: x[1]['count'], reverse=True)\n        \n        return [\n            {\n                'ip_address': ip,\n                'event_count': data['count'],\n                'event_types': list(data['event_types'])\n            }\n            for ip, data in sorted_ips[:limit]\n        ]\n\n# Security middleware and dependencies\nsecurity_monitor = SecurityMonitor()\nrate_limiter = RateLimiter()\ninput_sanitizer = InputSanitizer()\nauth_manager = AuthenticationManager()\nsecurity = HTTPBearer()\n\ndef get_client_ip(request: Request) -> str:\n    \"\"\"Get client IP address considering proxies\"\"\"\n    forwarded_for = request.headers.get('x-forwarded-for')\n    if forwarded_for:\n        return forwarded_for.split(',')[0].strip()\n    return request.client.host\n\nasync def security_middleware(request: Request):\n    \"\"\"Main security middleware\"\"\"\n    client_ip = get_client_ip(request)\n    \n    # Check if IP is blocked\n    if rate_limiter.is_ip_blocked(client_ip):\n        security_monitor.log_security_event(\n            'blocked_ip_access', 'high', request,\n            details={'action': 'blocked_ip_attempted_access'}\n        )\n        raise HTTPException(status_code=403, detail=\"Access forbidden\")\n    \n    # Rate limiting\n    allowed, rate_info = rate_limiter.check_rate_limit(client_ip, 'per_ip')\n    if not allowed:\n        security_monitor.log_security_event(\n            'rate_limit_exceeded', 'medium', request,\n            details={'rate_info': rate_info}\n        )\n        \n        # Block IP after repeated violations\n        violation_key = f\"rate_violations:{client_ip}\"\n        try:\n            violations = rate_limiter.redis_client.incr(violation_key)\n            rate_limiter.redis_client.expire(violation_key, 3600)\n            \n            if violations >= 3:  # Block after 3 violations in an hour\n                rate_limiter.block_ip(client_ip, 3600, \"Repeated rate limit violations\")\n        except:\n            pass\n        \n        raise HTTPException(\n            status_code=429, \n            detail=\"Rate limit exceeded\",\n            headers={\n                \"X-RateLimit-Limit\": str(rate_info['limit']),\n                \"X-RateLimit-Remaining\": \"0\",\n                \"X-RateLimit-Reset\": str(rate_info['reset_time'])\n            }\n        )\n    \n    return rate_info\n\nasync def verify_api_key(credentials: HTTPAuthorizationCredentials = Depends(security)) -> str:\n    \"\"\"Verify API key authentication\"\"\"\n    api_key = credentials.credentials\n    username = auth_manager.verify_api_key(api_key)\n    \n    if not username:\n        raise HTTPException(status_code=401, detail=\"Invalid API key\")\n    \n    return username\n\nasync def verify_jwt_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -> Dict[str, Any]:\n    \"\"\"Verify JWT token authentication\"\"\"\n    token = credentials.credentials\n    user_info = auth_manager.verify_token(token)\n    \n    if not user_info:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n    \n    return user_info